<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · DiffOpt.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DiffOpt.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../manual/">Manual</a></li><li><a class="tocitem" href="../usage/">Usage</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../matrix-inversion-manual/">Differentiating a simple QP by hand</a></li><li><a class="tocitem" href="../chainrules_unit/">ChainRules integration (Relaxed Unit Commitment)</a></li><li><a class="tocitem" href="../solve-conic-1/">Solving conic with PSD and SOC constraints</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../examples/autotuning-ridge/">Auto-tuning Hyperparameters</a></li><li><a class="tocitem" href="../examples/sensitivity-analysis-svm/">Sensitivity Analysis of SVM</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jump-dev/DiffOpt.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><ul><li><a href="#DiffOpt.AbstractLazyScalarFunction"><code>DiffOpt.AbstractLazyScalarFunction</code></a></li><li><a href="#DiffOpt.BackwardInVariablePrimal"><code>DiffOpt.BackwardInVariablePrimal</code></a></li><li><a href="#DiffOpt.BackwardOutConstraint"><code>DiffOpt.BackwardOutConstraint</code></a></li><li><a href="#DiffOpt.BackwardOutObjective"><code>DiffOpt.BackwardOutObjective</code></a></li><li><a href="#DiffOpt.ForwardInConstraint"><code>DiffOpt.ForwardInConstraint</code></a></li><li><a href="#DiffOpt.ForwardInObjective"><code>DiffOpt.ForwardInObjective</code></a></li><li><a href="#DiffOpt.ForwardOutVariablePrimal"><code>DiffOpt.ForwardOutVariablePrimal</code></a></li><li><a href="#DiffOpt.IndexMappedFunction"><code>DiffOpt.IndexMappedFunction</code></a></li><li><a href="#DiffOpt.MOItoJuMP"><code>DiffOpt.MOItoJuMP</code></a></li><li><a href="#DiffOpt.MatrixScalarQuadraticFunction"><code>DiffOpt.MatrixScalarQuadraticFunction</code></a></li><li><a href="#DiffOpt.MatrixVectorAffineFunction"><code>DiffOpt.MatrixVectorAffineFunction</code></a></li><li><a href="#DiffOpt.ProductOfSets"><code>DiffOpt.ProductOfSets</code></a></li><li><a href="#DiffOpt.ProgramClass"><code>DiffOpt.ProgramClass</code></a></li><li><a href="#DiffOpt.ProgramClassCode"><code>DiffOpt.ProgramClassCode</code></a></li><li><a href="#DiffOpt.ProgramClassUsed"><code>DiffOpt.ProgramClassUsed</code></a></li><li><a href="#DiffOpt.VectorScalarAffineFunction"><code>DiffOpt.VectorScalarAffineFunction</code></a></li><li><a href="#DiffOpt.Dπ-Union{Tuple{T}, Tuple{Vector{T}, MathOptInterface.ModelLike, DiffOpt.ProductOfSets, MathOptInterface.Utilities.IndexMap}} where T"><code>DiffOpt.Dπ</code></a></li><li><a href="#DiffOpt._backward_conic-Tuple{DiffOpt.Optimizer}"><code>DiffOpt._backward_conic</code></a></li><li><a href="#DiffOpt._backward_quad-Tuple{DiffOpt.Optimizer}"><code>DiffOpt._backward_quad</code></a></li><li><a href="#DiffOpt._forward_conic-Tuple{DiffOpt.Optimizer}"><code>DiffOpt._forward_conic</code></a></li><li><a href="#DiffOpt._forward_quad-Tuple{DiffOpt.Optimizer}"><code>DiffOpt._forward_quad</code></a></li><li><a href="#DiffOpt.backward-Tuple{DiffOpt.Optimizer}"><code>DiffOpt.backward</code></a></li><li><a href="#DiffOpt.create_LHS_matrix"><code>DiffOpt.create_LHS_matrix</code></a></li><li><a href="../manual/#DiffOpt.diff_optimizer"><code>DiffOpt.diff_optimizer</code></a></li><li><a href="#DiffOpt.diff_optimizer-Tuple{Any}"><code>DiffOpt.diff_optimizer</code></a></li><li><a href="#DiffOpt.forward-Tuple{DiffOpt.Optimizer}"><code>DiffOpt.forward</code></a></li><li><a href="#DiffOpt.get_problem_data-Tuple{MathOptInterface.AbstractOptimizer}"><code>DiffOpt.get_problem_data</code></a></li><li><a href="#DiffOpt.map_rows-Tuple{Function, Any, DiffOpt.ProductOfSets, MathOptInterface.Utilities.IndexMap, Union{DiffOpt.Flattened, DiffOpt.Nested}}"><code>DiffOpt.map_rows</code></a></li><li><a href="#DiffOpt.quad_sym_half"><code>DiffOpt.quad_sym_half</code></a></li><li><a href="#DiffOpt.standard_form"><code>DiffOpt.standard_form</code></a></li><li><a href="#DiffOpt.π-Union{Tuple{T}, Tuple{Vector{T}, MathOptInterface.ModelLike, DiffOpt.ProductOfSets, MathOptInterface.Utilities.IndexMap}} where T"><code>DiffOpt.π</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.AbstractLazyScalarFunction" href="#DiffOpt.AbstractLazyScalarFunction"><code>DiffOpt.AbstractLazyScalarFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractLazyScalarFunction &lt;: MOI.AbstractScalarFunction end</code></pre><p>Subtype of <code>MOI.AbstractScalarFunction</code> that is not a standard MOI scalar function but can be converted to one using <a href="#DiffOpt.standard_form"><code>standard_form</code></a>.</p><p>The function can also be inspected lazily using <code>JuMP.coefficient</code> or <a href="#DiffOpt.quad_sym_half"><code>quad_sym_half</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.BackwardInVariablePrimal" href="#DiffOpt.BackwardInVariablePrimal"><code>DiffOpt.BackwardInVariablePrimal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BackwardInVariablePrimal &lt;: MOI.AbstractVariableAttribute</code></pre><p>A <code>MOI.AbstractVariableAttribute</code> to set input data to backward differentiation, that is, problem solution.</p><p>For instance, to set the tangent of the variable of index <code>vi</code>, do the following:</p><pre><code class="language-julia hljs">MOI.set(model, DiffOpt.BackwardInVariablePrimal(), x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.BackwardOutConstraint" href="#DiffOpt.BackwardOutConstraint"><code>DiffOpt.BackwardOutConstraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BackwardOutConstraint</code></pre><p>An <code>MOI.AbstractConstraintAttribute</code> to get output data to backward differentiation, that is, problem input data.</p><p>For instance, if the following returns <code>x + 2y + 5</code>, it means that the tangent has coordinate <code>1</code> for the coefficient of <code>x</code>, coordinate <code>2</code> for the coefficient of <code>y</code> and <code>5</code> for the function constant. If the constraint is of the form <code>func == constant</code> or <code>func &lt;= constant</code>, the tangent for the constant on the right-hand side is <code>-5</code>.</p><pre><code class="language-julia hljs">MOI.get(model, DiffOpt.BackwardOutConstraint(), ci)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.BackwardOutObjective" href="#DiffOpt.BackwardOutObjective"><code>DiffOpt.BackwardOutObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BackwardOutObjective &lt;: MOI.AbstractModelAttribute</code></pre><p>A <code>MOI.AbstractModelAttribute</code> to get output data to backward differentiation, that is, problem input data.</p><p>For instance, to get the tangent of the objective function corresponding to the tangent given to <code>BackwardInVariablePrimal</code>, do the following:</p><pre><code class="language-julia hljs">func = MOI.get(model, DiffOpt.BackwardOutObjective)</code></pre><p>Then, to get the sensitivity of the linear term with variable <code>x</code>, do</p><pre><code class="language-julia hljs">JuMP.coefficient(func, x)</code></pre><p>To get the sensitivity with respect to the quadratic term with variables <code>x</code> and <code>y</code>, do either</p><pre><code class="language-julia hljs">JuMP.coefficient(func, x, y)</code></pre><p>or</p><pre><code class="language-julia hljs">DiffOpt.quad_sym_half(func, x, y)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>These two lines are <strong>not</strong> equivalent in case <code>x == y</code>, see <a href="#DiffOpt.quad_sym_half"><code>quad_sym_half</code></a> for the details on the difference between these two functions.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.ForwardInConstraint" href="#DiffOpt.ForwardInConstraint"><code>DiffOpt.ForwardInConstraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ForwardInConstraint &lt;: MOI.AbstractConstraintAttribute</code></pre><p>A <code>MOI.AbstractConstraintAttribute</code> to set input data to forward differentiation, that is, problem input data.</p><p>For instance, if the scalar constraint of index <code>ci</code> contains <code>θ * (x + 2y) &lt;= 5θ</code>, for the purpose of computing the derivative with respect to <code>θ</code>, the following should be set:</p><pre><code class="language-julia hljs">MOI.set(model, DiffOpt.ForwardInConstraint(), ci, 1.0 * x + 2.0 * y - 5.0)</code></pre><p>Note that we use <code>-5</code> as the <code>ForwardInConstraint</code> sets the tangent of the ConstraintFunction so we consider the expression <code>θ * (x + 2y - 5)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.ForwardInObjective" href="#DiffOpt.ForwardInObjective"><code>DiffOpt.ForwardInObjective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ForwardInObjective &lt;: MOI.AbstractModelAttribute</code></pre><p>A <code>MOI.AbstractModelAttribute</code> to set input data to forward differentiation, that is, problem input data. The possible values are any <code>MOI.AbstractScalarFunction</code>. A <code>MOI.ScalarQuadraticFunction</code> can only be used in linearly constrained quadratic models.</p><p>For instance, if the objective contains <code>θ * (x + 2y)</code>, for the purpose of computinig the derivative with respect to <code>θ</code>, the following should be set:</p><pre><code class="language-julia hljs">MOI.set(model, DiffOpt.ForwardInObjective(), 1.0 * x + 2.0 * y)</code></pre><p>where <code>x</code> and <code>y</code> are the relevant <code>MOI.VariableIndex</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.ForwardOutVariablePrimal" href="#DiffOpt.ForwardOutVariablePrimal"><code>DiffOpt.ForwardOutVariablePrimal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ForwardOutVariablePrimal &lt;: MOI.AbstractVariableAttribute</code></pre><p>A <code>MOI.AbstractVariableAttribute</code> to get output data from forward differentiation, that is, problem solution.</p><p>For instance, to get the tangent of the variable of index <code>vi</code> corresponding to the tangents given to <code>ForwardInObjective</code> and <code>ForwardInConstraint</code>, do the following:</p><pre><code class="language-julia hljs">MOI.get(model, DiffOpt.ForwardOutVariablePrimal(), vi)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.IndexMappedFunction" href="#DiffOpt.IndexMappedFunction"><code>DiffOpt.IndexMappedFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndexMappedFunction{F&lt;:MOI.AbstractFunction} &lt;: AbstractLazyScalarFunction</code></pre><p>Lazily represents the function <code>MOI.Utilities.map_indices(index_map, DiffOpt.standard_form(func))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.MOItoJuMP" href="#DiffOpt.MOItoJuMP"><code>DiffOpt.MOItoJuMP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MOItoJuMP{F&lt;:MOI.AbstractScalarFunction} &lt;: JuMP.AbstractJuMPScalar</code></pre><p>Lazily represents the function <code>JuMP.jump_function(model, DiffOpt.standard_form(func))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.MatrixScalarQuadraticFunction" href="#DiffOpt.MatrixScalarQuadraticFunction"><code>DiffOpt.MatrixScalarQuadraticFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MatrixScalarQuadraticFunction{T, VT, MT} &lt;: MOI.AbstractScalarFunction
    affine::VectorScalarAffineFunction{T,VT}
    terms::MT
end</code></pre><p>Represents the function <code>x&#39; * terms * x / 2 + affine</code> as an <code>MOI.AbstractScalarFunction</code> where <code>x[i] = MOI.VariableIndex(i)</code>. Use <a href="#DiffOpt.standard_form"><code>standard_form</code></a> to convert it to a <code>MOI.ScalarQuadraticFunction{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.MatrixVectorAffineFunction" href="#DiffOpt.MatrixVectorAffineFunction"><code>DiffOpt.MatrixVectorAffineFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MatrixVectorAffineFunction{T, VT} &lt;: MOI.AbstractVectorFunction</code></pre><p>Represents the function <code>terms * x + constant</code> as an <code>MOI.AbstractVectorFunction</code> where <code>x[i] = MOI.VariableIndex(i)</code>. Use <a href="#DiffOpt.standard_form"><code>standard_form</code></a> to convert it to a <code>MOI.VectorAffineFunction{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.ProductOfSets" href="#DiffOpt.ProductOfSets"><code>DiffOpt.ProductOfSets</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProductOfSets{T} &lt;: MOI.Utilities.OrderedProductOfSets{T}</code></pre><p>The <code>MOI.Utilities.@product_of_sets</code> macro requires to know the list of sets at compile time. In DiffOpt however, the list depends on what the user is going to use as set as DiffOpt supports any set as long as it implements the required function of MathOptSetDistances. For this type, the list of sets can be given a run-time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.ProgramClass" href="#DiffOpt.ProgramClass"><code>DiffOpt.ProgramClass</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProgramClass &lt;: MOI.AbstractOptimizerAttribute</code></pre><p>Determines which program class to used from <a href="#DiffOpt.ProgramClassCode"><code>ProgramClassCode</code></a>. The default is <code>AUTOMATIC</code>.</p><p>One important advantage of setting the class explicitly is that it will allow necessary bridges to be used. If the class is <code>AUTOMATIC</code> then <code>DiffOpt.Optimizer</code> will report that it supports both objective and constraints of the QP and CP classes. For instance, it will reports that is supports both quadratic objective and conic constraints. However, at the differentiation stage, we won&#39;t be able to differentiate since QP does not support conic constraints and CP does not support quadratic objective. On the other hand, if the <code>ProgramClass</code> is set to <code>CONIC</code> then <code>DiffOpt.Optimizer</code> will report that it does not support quadratic objective hence it will be bridged to second-order cone constraints and we will be able to use CP to differentiate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.ProgramClassCode" href="#DiffOpt.ProgramClassCode"><code>DiffOpt.ProgramClassCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@enum ProgramClassCode QUADRATIC CONIC AUTOMATIC</code></pre><p>Program class used by DiffOpt. DiffOpt implements differentiation of two different program class:</p><ol><li>Quadratic Program (QP): quadratic objective and linear constraints and</li><li>Conic Program (CP): linear objective and conic constraints.</li></ol><p><code>AUTOMATIC</code> which means that the class will be automatically selected given the problem data: if any constraint is conic, CP is used and QP is used otherwise. See <a href="#DiffOpt.ProgramClass"><code>ProgramClass</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.ProgramClassUsed" href="#DiffOpt.ProgramClassUsed"><code>DiffOpt.ProgramClassUsed</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProgramClassUsed &lt;: MOI.AbstractOptimizerAttribute</code></pre><p>Program class actually used, same as <a href="#DiffOpt.ProgramClass"><code>ProgramClass</code></a> except that it does not return <code>AUTOMATIC</code> but the class automatically chosen instead. This attribute is read-only, it cannot be set, set <a href="#DiffOpt.ProgramClass"><code>ProgramClass</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.VectorScalarAffineFunction" href="#DiffOpt.VectorScalarAffineFunction"><code>DiffOpt.VectorScalarAffineFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorScalarAffineFunction{T, VT} &lt;: MOI.AbstractScalarFunction</code></pre><p>Represents the function <code>x ⋅ terms + constant</code> as an <code>MOI.AbstractScalarFunction</code> where <code>x[i] = MOI.VariableIndex(i)</code>. Use <a href="#DiffOpt.standard_form"><code>standard_form</code></a> to convert it to a <code>MOI.ScalarAffineFunction{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.Dπ-Union{Tuple{T}, Tuple{Vector{T}, MathOptInterface.ModelLike, DiffOpt.ProductOfSets, MathOptInterface.Utilities.IndexMap}} where T" href="#DiffOpt.Dπ-Union{Tuple{T}, Tuple{Vector{T}, MathOptInterface.ModelLike, DiffOpt.ProductOfSets, MathOptInterface.Utilities.IndexMap}} where T"><code>DiffOpt.Dπ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Dπ(v::Vector{Float64}, model, cones::ProductOfSets, index_map::MOIU.IndexMap)</code></pre><p>Given a <code>model</code>, its <code>cones</code> and the <code>index_map</code> from the indices of <code>model</code> to the indices of <code>cones</code>, find the gradient of the projection of the vectors <code>v</code> of length equal to the number of rows in the conic form onto the cartesian product of the cones corresponding to these rows. For more info, refer to https://github.com/matbesancon/MathOptSetDistances.jl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt._backward_conic-Tuple{DiffOpt.Optimizer}" href="#DiffOpt._backward_conic-Tuple{DiffOpt.Optimizer}"><code>DiffOpt._backward_conic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_backward_conic(model::Optimizer, dx::Vector{Float64}, dy::Vector{Float64}, ds::Vector{Float64})</code></pre><p>Method to compute the product of the transpose of the derivative (Jacobian) at the conic program parameters <code>A</code>, <code>b</code>, <code>c</code>  to the perturbations <code>dx</code>, <code>dy</code>, <code>ds</code>. This is similar to <a href="#DiffOpt.backward-Tuple{DiffOpt.Optimizer}"><code>backward</code></a>.</p><p>For theoretical background, refer Section 3 of Differentiating Through a Cone Program, https://arxiv.org/abs/1904.09043</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt._backward_quad-Tuple{DiffOpt.Optimizer}" href="#DiffOpt._backward_quad-Tuple{DiffOpt.Optimizer}"><code>DiffOpt._backward_quad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_backward_quad(model::Optimizer)</code></pre><p>Method to differentiate optimal solution <code>z</code> and return product of jacobian matrices (<code>dz / dQ</code>, <code>dz / dq</code>, etc) with the backward pass vector <code>dl / dz</code></p><p>The method computes the product of</p><ol><li>jacobian of problem solution <code>z*</code> with respect to  problem parameters set with the <a href="#DiffOpt.BackwardInVariablePrimal"><code>BackwardInVariablePrimal</code></a></li><li>a backward pass vector <code>dl / dz</code>, where <code>l</code> can be a loss function</li></ol><p>Note that this method <em>does not returns</em> the actual jacobians.</p><p>For more info refer eqn(7) and eqn(8) of https://arxiv.org/pdf/1703.00443.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt._forward_conic-Tuple{DiffOpt.Optimizer}" href="#DiffOpt._forward_conic-Tuple{DiffOpt.Optimizer}"><code>DiffOpt._forward_conic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_forward_conic(model::Optimizer)</code></pre><p>Method to compute the product of the derivative (Jacobian) at the conic program parameters <code>A</code>, <code>b</code>, <code>c</code>  to the perturbations <code>dA</code>, <code>db</code>, <code>dc</code>. This is similar to <a href="#DiffOpt.forward-Tuple{DiffOpt.Optimizer}"><code>forward</code></a>.</p><p>For theoretical background, refer Section 3 of Differentiating Through a Cone Program, https://arxiv.org/abs/1904.09043</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt._forward_quad-Tuple{DiffOpt.Optimizer}" href="#DiffOpt._forward_quad-Tuple{DiffOpt.Optimizer}"><code>DiffOpt._forward_quad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_forward_quad(model::Optimizer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.backward-Tuple{DiffOpt.Optimizer}" href="#DiffOpt.backward-Tuple{DiffOpt.Optimizer}"><code>DiffOpt.backward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">backward(model::Optimizer)</code></pre><p>Wrapper method for the backward pass. This method will consider as input a currently solved problem and differentials with respect to the solution set with the <a href="#DiffOpt.BackwardInVariablePrimal"><code>BackwardInVariablePrimal</code></a> attribute. The output problem data differentials can be queried with the attributes <a href="#DiffOpt.BackwardOutObjective"><code>BackwardOutObjective</code></a> and <a href="#DiffOpt.BackwardOutConstraint"><code>BackwardOutConstraint</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.create_LHS_matrix" href="#DiffOpt.create_LHS_matrix"><code>DiffOpt.create_LHS_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_LHS_matrix(z, λ, Q, G, h, A=nothing)</code></pre><p>Inverse matrix specified on RHS of eqn(7) in https://arxiv.org/pdf/1703.00443.pdf</p><p>Helper method while calling <code>_backward_quad</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.diff_optimizer-Tuple{Any}" href="#DiffOpt.diff_optimizer-Tuple{Any}"><code>DiffOpt.diff_optimizer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diff_optimizer(optimizer_constructor)::Optimizer</code></pre><p>Creates a <code>DiffOpt.Optimizer</code>, which is an MOI layer with an internal optimizer and other utility methods. Results (primal, dual and slack values) are obtained by querying the internal optimizer instantiated using the <code>optimizer_constructor</code>. These values are required for find jacobians with respect to problem data.</p><p>One define a differentiable model by using any solver of choice. Example:</p><pre><code class="language-julia hljs">julia&gt; using DiffOpt, GLPK

julia&gt; model = diff_optimizer(GLPK.Optimizer)
julia&gt; model.add_variable(x)
julia&gt; model.add_constraint(...)

julia&gt; _backward_quad(model)  # for convex quadratic models

julia&gt; _backward_quad(model)  # for convex conic models</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.forward-Tuple{DiffOpt.Optimizer}" href="#DiffOpt.forward-Tuple{DiffOpt.Optimizer}"><code>DiffOpt.forward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">forward(model::Optimizer)</code></pre><p>Wrapper method for the forward pass. This method will consider as input a currently solved problem and differentials with respect to problem data set with the <a href="#DiffOpt.ForwardInObjective"><code>ForwardInObjective</code></a> and  <a href="#DiffOpt.ForwardInConstraint"><code>ForwardInConstraint</code></a> attributes. The output solution differentials can be queried with the attribute <a href="#DiffOpt.ForwardOutVariablePrimal"><code>ForwardOutVariablePrimal</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.get_problem_data-Tuple{MathOptInterface.AbstractOptimizer}" href="#DiffOpt.get_problem_data-Tuple{MathOptInterface.AbstractOptimizer}"><code>DiffOpt.get_problem_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_problem_data(model::MOI.AbstractOptimizer)</code></pre><p>Return problem parameters as matrices along with other program info such as number of constraints, variables, etc</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.map_rows-Tuple{Function, Any, DiffOpt.ProductOfSets, MathOptInterface.Utilities.IndexMap, Union{DiffOpt.Flattened, DiffOpt.Nested}}" href="#DiffOpt.map_rows-Tuple{Function, Any, DiffOpt.ProductOfSets, MathOptInterface.Utilities.IndexMap, Union{DiffOpt.Flattened, DiffOpt.Nested}}"><code>DiffOpt.map_rows</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_rows(f::Function, model, cones::ProductOfSets, index_map::MOIU.IndexMap, map_mode::Union{Nested{T}, Flattened{T}})</code></pre><p>Given a <code>model</code>, its <code>cones</code>, the <code>index_map</code> from the indices of <code>model</code> to the indices of <code>cones</code> and <code>map_mode</code> of type <code>Nested</code> (resp. <code>Flattened</code>), return a <code>Vector{T}</code> of length equal to the number of cones (resp. rows) in the conic form where the value for the index (resp. rows) corresponding to each cone is equal to <code>f(ci, r)</code> where <code>ci</code> is the corresponding constraint index in <code>model</code> and <code>r</code> is a <code>UnitRange</code> of the corresponding rows in the conic form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.quad_sym_half" href="#DiffOpt.quad_sym_half"><code>DiffOpt.quad_sym_half</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">quad_sym_half(func, vi1::MOI.VariableIndex, vi2::MOI.VariableIndex)</code></pre><p>Return <code>Q[i,j] = Q[j,i]</code> where the quadratic terms of <code>func</code> is represented by <code>x&#39; Q x / 2</code> for a symmetric matrix <code>Q</code> where <code>x[i] = vi1</code> and <code>x[j] = vi2</code>. Note that while this is equal to <code>JuMP.coefficient(func, vi1, vi2)</code> if <code>vi1 != vi2</code>, in the case <code>vi1 == vi2</code>, it is rather equal to <code>2JuMP.coefficient(func, vi1, vi2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.standard_form" href="#DiffOpt.standard_form"><code>DiffOpt.standard_form</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">standard_form(func::AbstractLazyScalarFunction)</code></pre><p>Converts <code>func</code> to a standard MOI scalar function.</p><pre><code class="nohighlight hljs">standard_form(func::MOItoJuMP)</code></pre><p>Converts <code>func</code> to a standard JuMP scalar function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.π-Union{Tuple{T}, Tuple{Vector{T}, MathOptInterface.ModelLike, DiffOpt.ProductOfSets, MathOptInterface.Utilities.IndexMap}} where T" href="#DiffOpt.π-Union{Tuple{T}, Tuple{Vector{T}, MathOptInterface.ModelLike, DiffOpt.ProductOfSets, MathOptInterface.Utilities.IndexMap}} where T"><code>DiffOpt.π</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">π(v::Vector{Float64}, model::MOI.ModelLike, cones::ProductOfSets, index_map::MOIU.IndexMap)</code></pre><p>Given a <code>model</code>, its <code>cones</code> and the <code>index_map</code> from the indices of <code>model</code> to the indices of <code>cones</code>, find the projection of the vectors <code>v</code> of length equal to the number of rows in the conic form onto the cartesian product of the cones corresponding to these rows. For more info, refer to https://github.com/matbesancon/MathOptSetDistances.jl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../usage/">« Usage</a><a class="docs-footer-nextpage" href="../matrix-inversion-manual/">Differentiating a simple QP by hand »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Friday 3 December 2021 09:11">Friday 3 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
