<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · DiffOpt.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DiffOpt.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../manual/">Manual</a></li><li><a class="tocitem" href="../usage/">Usage</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../examples/Thermal_Generation_Dispatch_Example/">Thermal Generation Dispatch Example</a></li><li><a class="tocitem" href="../examples/autotuning-ridge/">Auto-tuning Hyperparameters</a></li><li><a class="tocitem" href="../examples/chainrules_unit/">ChainRules integration demo: Relaxed Unit Commitment</a></li><li><a class="tocitem" href="../examples/custom-relu/">Custom ReLU layer</a></li><li><a class="tocitem" href="../examples/matrix-inversion-manual/">Differentiating a QP wrt a single variable</a></li><li><a class="tocitem" href="../examples/nearest_correlation/">Nearest correlation</a></li><li><a class="tocitem" href="../examples/polyhedral_project/">Polyhedral QP layer</a></li><li><a class="tocitem" href="../examples/sensitivity-analysis-ridge/">Sensitivity Analysis of Ridge Regression</a></li><li><a class="tocitem" href="../examples/sensitivity-analysis-svm/">Sensitivity Analysis of SVM</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jump-dev/DiffOpt.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><ul><li><a href="#DiffOpt.AbstractLazyScalarFunction"><code>DiffOpt.AbstractLazyScalarFunction</code></a></li><li><a href="#DiffOpt.AbstractModel"><code>DiffOpt.AbstractModel</code></a></li><li><a href="#DiffOpt.ConicProgram.Model"><code>DiffOpt.ConicProgram.Model</code></a></li><li><a href="#DiffOpt.DifferentiateTimeSec"><code>DiffOpt.DifferentiateTimeSec</code></a></li><li><a href="#DiffOpt.ForwardConstraintFunction"><code>DiffOpt.ForwardConstraintFunction</code></a></li><li><a href="#DiffOpt.ForwardObjectiveFunction"><code>DiffOpt.ForwardObjectiveFunction</code></a></li><li><a href="#DiffOpt.ForwardVariablePrimal"><code>DiffOpt.ForwardVariablePrimal</code></a></li><li><a href="#DiffOpt.IndexMappedFunction"><code>DiffOpt.IndexMappedFunction</code></a></li><li><a href="#DiffOpt.MOItoJuMP"><code>DiffOpt.MOItoJuMP</code></a></li><li><a href="#DiffOpt.MatrixScalarQuadraticFunction"><code>DiffOpt.MatrixScalarQuadraticFunction</code></a></li><li><a href="#DiffOpt.MatrixVectorAffineFunction"><code>DiffOpt.MatrixVectorAffineFunction</code></a></li><li><a href="#DiffOpt.ModelConstructor"><code>DiffOpt.ModelConstructor</code></a></li><li><a href="#DiffOpt.ObjectiveFunctionAttribute"><code>DiffOpt.ObjectiveFunctionAttribute</code></a></li><li><a href="#DiffOpt.ProductOfSets"><code>DiffOpt.ProductOfSets</code></a></li><li><a href="#DiffOpt.QuadraticProgram.LinearAlgebraSolver"><code>DiffOpt.QuadraticProgram.LinearAlgebraSolver</code></a></li><li><a href="#DiffOpt.QuadraticProgram.Model"><code>DiffOpt.QuadraticProgram.Model</code></a></li><li><a href="#DiffOpt.ReverseConstraintFunction"><code>DiffOpt.ReverseConstraintFunction</code></a></li><li><a href="#DiffOpt.ReverseObjectiveFunction"><code>DiffOpt.ReverseObjectiveFunction</code></a></li><li><a href="#DiffOpt.ReverseVariablePrimal"><code>DiffOpt.ReverseVariablePrimal</code></a></li><li><a href="#DiffOpt.SparseVectorAffineFunction"><code>DiffOpt.SparseVectorAffineFunction</code></a></li><li><a href="#DiffOpt.VectorScalarAffineFunction"><code>DiffOpt.VectorScalarAffineFunction</code></a></li><li><a href="#DiffOpt.Dπ-Union{Tuple{T}, Tuple{Vector{T}, MathOptInterface.ModelLike, DiffOpt.ProductOfSets}} where T"><code>DiffOpt.Dπ</code></a></li><li><a href="#DiffOpt.QuadraticProgram.create_LHS_matrix"><code>DiffOpt.QuadraticProgram.create_LHS_matrix</code></a></li><li><a href="#DiffOpt.QuadraticProgram.solve_system-NTuple{4, Any}"><code>DiffOpt.QuadraticProgram.solve_system</code></a></li><li><a href="#DiffOpt.add_all_model_constructors-Tuple{Any}"><code>DiffOpt.add_all_model_constructors</code></a></li><li><a href="#DiffOpt.add_model_constructor-Tuple{DiffOpt.Optimizer, Any}"><code>DiffOpt.add_model_constructor</code></a></li><li><a href="#DiffOpt.dU_from_dQ!-Tuple{Any, Any}"><code>DiffOpt.dU_from_dQ!</code></a></li><li><a href="../manual/#DiffOpt.diff_optimizer"><code>DiffOpt.diff_optimizer</code></a></li><li><a href="#DiffOpt.diff_optimizer-Tuple{Any}"><code>DiffOpt.diff_optimizer</code></a></li><li><a href="#DiffOpt.forward_differentiate!"><code>DiffOpt.forward_differentiate!</code></a></li><li><a href="#DiffOpt.map_rows-Tuple{Function, Any, DiffOpt.ProductOfSets, Union{DiffOpt.Flattened, DiffOpt.Nested}}"><code>DiffOpt.map_rows</code></a></li><li><a href="#DiffOpt.quad_sym_half"><code>DiffOpt.quad_sym_half</code></a></li><li><a href="#DiffOpt.reverse_differentiate!"><code>DiffOpt.reverse_differentiate!</code></a></li><li><a href="#DiffOpt.standard_form"><code>DiffOpt.standard_form</code></a></li><li><a href="#DiffOpt.ΔQ_from_ΔU!-Tuple{Any, Any}"><code>DiffOpt.ΔQ_from_ΔU!</code></a></li><li><a href="#DiffOpt.π-Union{Tuple{T}, Tuple{Vector{T}, MathOptInterface.ModelLike, DiffOpt.ProductOfSets}} where T"><code>DiffOpt.π</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.AbstractLazyScalarFunction" href="#DiffOpt.AbstractLazyScalarFunction"><code>DiffOpt.AbstractLazyScalarFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractLazyScalarFunction &lt;: MOI.AbstractScalarFunction end</code></pre><p>Subtype of <code>MOI.AbstractScalarFunction</code> that is not a standard MOI scalar function but can be converted to one using <a href="#DiffOpt.standard_form"><code>standard_form</code></a>.</p><p>The function can also be inspected lazily using <code>JuMP.coefficient</code> or <a href="#DiffOpt.quad_sym_half"><code>quad_sym_half</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.AbstractModel" href="#DiffOpt.AbstractModel"><code>DiffOpt.AbstractModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractModel &lt;: MOI.ModelLike end</code></pre><p>Model supporting <a href="#DiffOpt.forward_differentiate!"><code>forward_differentiate!</code></a> and <a href="#DiffOpt.reverse_differentiate!"><code>reverse_differentiate!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.DifferentiateTimeSec" href="#DiffOpt.DifferentiateTimeSec"><code>DiffOpt.DifferentiateTimeSec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DifferentiateTimeSec()</code></pre><p>A model attribute for the total elapsed time (in seconds) for computing the differentiation information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.ForwardConstraintFunction" href="#DiffOpt.ForwardConstraintFunction"><code>DiffOpt.ForwardConstraintFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ForwardConstraintFunction &lt;: MOI.AbstractConstraintAttribute</code></pre><p>A <code>MOI.AbstractConstraintAttribute</code> to set input data to forward differentiation, that is, problem input data.</p><p>For instance, if the scalar constraint of index <code>ci</code> contains <code>θ * (x + 2y) &lt;= 5θ</code>, for the purpose of computing the derivative with respect to <code>θ</code>, the following should be set:</p><pre><code class="language-julia hljs">MOI.set(model, DiffOpt.ForwardConstraintFunction(), ci, 1.0 * x + 2.0 * y - 5.0)</code></pre><p>Note that we use <code>-5</code> as the <code>ForwardConstraintFunction</code> sets the tangent of the ConstraintFunction so we consider the expression <code>θ * (x + 2y - 5)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.ForwardObjectiveFunction" href="#DiffOpt.ForwardObjectiveFunction"><code>DiffOpt.ForwardObjectiveFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ForwardObjectiveFunction &lt;: MOI.AbstractModelAttribute</code></pre><p>A <code>MOI.AbstractModelAttribute</code> to set input data to forward differentiation, that is, problem input data. The possible values are any <code>MOI.AbstractScalarFunction</code>. A <code>MOI.ScalarQuadraticFunction</code> can only be used in linearly constrained quadratic models.</p><p>For instance, if the objective contains <code>θ * (x + 2y)</code>, for the purpose of computing the derivative with respect to <code>θ</code>, the following should be set:</p><pre><code class="language-julia hljs">MOI.set(model, DiffOpt.ForwardObjectiveFunction(), 1.0 * x + 2.0 * y)</code></pre><p>where <code>x</code> and <code>y</code> are the relevant <code>MOI.VariableIndex</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.ForwardVariablePrimal" href="#DiffOpt.ForwardVariablePrimal"><code>DiffOpt.ForwardVariablePrimal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ForwardVariablePrimal &lt;: MOI.AbstractVariableAttribute</code></pre><p>A <code>MOI.AbstractVariableAttribute</code> to get output data from forward differentiation, that is, problem solution.</p><p>For instance, to get the tangent of the variable of index <code>vi</code> corresponding to the tangents given to <code>ForwardObjectiveFunction</code> and <code>ForwardConstraintFunction</code>, do the following:</p><pre><code class="language-julia hljs">MOI.get(model, DiffOpt.ForwardVariablePrimal(), vi)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.IndexMappedFunction" href="#DiffOpt.IndexMappedFunction"><code>DiffOpt.IndexMappedFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndexMappedFunction{F&lt;:MOI.AbstractFunction} &lt;: AbstractLazyScalarFunction</code></pre><p>Lazily represents the function <code>MOI.Utilities.map_indices(index_map, DiffOpt.standard_form(func))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.MOItoJuMP" href="#DiffOpt.MOItoJuMP"><code>DiffOpt.MOItoJuMP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MOItoJuMP{F&lt;:MOI.AbstractScalarFunction} &lt;: JuMP.AbstractJuMPScalar</code></pre><p>Lazily represents the function <code>JuMP.jump_function(model, DiffOpt.standard_form(func))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.MatrixScalarQuadraticFunction" href="#DiffOpt.MatrixScalarQuadraticFunction"><code>DiffOpt.MatrixScalarQuadraticFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MatrixScalarQuadraticFunction{T, VT, MT} &lt;: MOI.AbstractScalarFunction
    affine::VectorScalarAffineFunction{T,VT}
    terms::MT
end</code></pre><p>Represents the function <code>x&#39; * terms * x / 2 + affine</code> as an <code>MOI.AbstractScalarFunction</code> where <code>x[i] = MOI.VariableIndex(i)</code>. Use <a href="#DiffOpt.standard_form"><code>standard_form</code></a> to convert it to a <code>MOI.ScalarQuadraticFunction{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.MatrixVectorAffineFunction" href="#DiffOpt.MatrixVectorAffineFunction"><code>DiffOpt.MatrixVectorAffineFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MatrixVectorAffineFunction{T, VT} &lt;: MOI.AbstractVectorFunction</code></pre><p>Represents the function <code>terms * x + constant</code> as an <code>MOI.AbstractVectorFunction</code> where <code>x[i] = MOI.VariableIndex(i)</code>. Use <a href="#DiffOpt.standard_form"><code>standard_form</code></a> to convert it to a <code>MOI.VectorAffineFunction{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.ModelConstructor" href="#DiffOpt.ModelConstructor"><code>DiffOpt.ModelConstructor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ModelConstructor &lt;: MOI.AbstractOptimizerAttribute</code></pre><p>Determines which subtype of <a href="#DiffOpt.AbstractModel"><code>DiffOpt.AbstractModel</code></a> to use for differentiation. When set to <code>nothing</code>, the first one out of <code>model.model_constructors</code> that support the problem is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.ObjectiveFunctionAttribute" href="#DiffOpt.ObjectiveFunctionAttribute"><code>DiffOpt.ObjectiveFunctionAttribute</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ObjectiveFunctionAttribute{A,F} &lt;: MOI.AbstractModelAttribute
    attr::A
end</code></pre><p>Objective function attribute <code>attr</code> for the function type <code>F</code>. The type <code>F</code> is used by a <code>MOI.Bridges.AbstractBridgeOptimizer</code> to keep track of its position in a chain of objective bridges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.ProductOfSets" href="#DiffOpt.ProductOfSets"><code>DiffOpt.ProductOfSets</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProductOfSets{T} &lt;: MOI.Utilities.OrderedProductOfSets{T}</code></pre><p>The <code>MOI.Utilities.@product_of_sets</code> macro requires to know the list of sets at compile time. In DiffOpt however, the list depends on what the user is going to use as set as DiffOpt supports any set as long as it implements the required function of MathOptSetDistances. For this type, the list of sets can be given a run-time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.ReverseConstraintFunction" href="#DiffOpt.ReverseConstraintFunction"><code>DiffOpt.ReverseConstraintFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReverseConstraintFunction</code></pre><p>An <code>MOI.AbstractConstraintAttribute</code> to get output data to reverse differentiation, that is, problem input data.</p><p>For instance, if the following returns <code>x + 2y + 5</code>, it means that the tangent has coordinate <code>1</code> for the coefficient of <code>x</code>, coordinate <code>2</code> for the coefficient of <code>y</code> and <code>5</code> for the function constant. If the constraint is of the form <code>func == constant</code> or <code>func &lt;= constant</code>, the tangent for the constant on the right-hand side is <code>-5</code>.</p><pre><code class="language-julia hljs">MOI.get(model, DiffOpt.ReverseConstraintFunction(), ci)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.ReverseObjectiveFunction" href="#DiffOpt.ReverseObjectiveFunction"><code>DiffOpt.ReverseObjectiveFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReverseObjectiveFunction &lt;: MOI.AbstractModelAttribute</code></pre><p>A <code>MOI.AbstractModelAttribute</code> to get output data to reverse differentiation, that is, problem input data.</p><p>For instance, to get the tangent of the objective function corresponding to the tangent given to <code>ReverseVariablePrimal</code>, do the following:</p><pre><code class="language-julia hljs">func = MOI.get(model, DiffOpt.ReverseObjectiveFunction())</code></pre><p>Then, to get the sensitivity of the linear term with variable <code>x</code>, do</p><pre><code class="language-julia hljs">JuMP.coefficient(func, x)</code></pre><p>To get the sensitivity with respect to the quadratic term with variables <code>x</code> and <code>y</code>, do either</p><pre><code class="language-julia hljs">JuMP.coefficient(func, x, y)</code></pre><p>or</p><pre><code class="language-julia hljs">DiffOpt.quad_sym_half(func, x, y)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>These two lines are <strong>not</strong> equivalent in case <code>x == y</code>, see <a href="#DiffOpt.quad_sym_half"><code>quad_sym_half</code></a> for the details on the difference between these two functions.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.ReverseVariablePrimal" href="#DiffOpt.ReverseVariablePrimal"><code>DiffOpt.ReverseVariablePrimal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReverseVariablePrimal &lt;: MOI.AbstractVariableAttribute</code></pre><p>A <code>MOI.AbstractVariableAttribute</code> to set input data to reverse differentiation, that is, problem solution.</p><p>For instance, to set the tangent of the variable of index <code>vi</code>, do the following:</p><pre><code class="language-julia hljs">MOI.set(model, DiffOpt.ReverseVariablePrimal(), x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.SparseVectorAffineFunction" href="#DiffOpt.SparseVectorAffineFunction"><code>DiffOpt.SparseVectorAffineFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SparseVectorAffineFunction{T} &lt;: MOI.AbstractVectorFunction
    terms::SparseArrays.SparseMatrixCSC{T,Int}
    constants::Vector{T}
end</code></pre><p>The vector-valued affine function <span>$A x + b$</span>, where:</p><ul><li><span>$A$</span> is the sparse matrix given by <code>terms</code></li><li><span>$b$</span> is the vector <code>constants</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.VectorScalarAffineFunction" href="#DiffOpt.VectorScalarAffineFunction"><code>DiffOpt.VectorScalarAffineFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorScalarAffineFunction{T, VT} &lt;: MOI.AbstractScalarFunction</code></pre><p>Represents the function <code>x ⋅ terms + constant</code> as an <code>MOI.AbstractScalarFunction</code> where <code>x[i] = MOI.VariableIndex(i)</code>. Use <a href="#DiffOpt.standard_form"><code>standard_form</code></a> to convert it to a <code>MOI.ScalarAffineFunction{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.Dπ-Union{Tuple{T}, Tuple{Vector{T}, MathOptInterface.ModelLike, DiffOpt.ProductOfSets}} where T" href="#DiffOpt.Dπ-Union{Tuple{T}, Tuple{Vector{T}, MathOptInterface.ModelLike, DiffOpt.ProductOfSets}} where T"><code>DiffOpt.Dπ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Dπ(v::Vector{Float64}, model, cones::ProductOfSets)</code></pre><p>Given a <code>model</code>, its <code>cones</code>, find the gradient of the projection of the vectors <code>v</code> of length equal to the number of rows in the conic form onto the cartesian product of the cones corresponding to these rows. For more info, refer to https://github.com/matbesancon/MathOptSetDistances.jl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.add_all_model_constructors-Tuple{Any}" href="#DiffOpt.add_all_model_constructors-Tuple{Any}"><code>DiffOpt.add_all_model_constructors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_all_model_constructors(model)</code></pre><p>Add all constructors of <a href="#DiffOpt.AbstractModel"><code>AbstractModel</code></a> defined in this package to <code>model</code> with <a href="#DiffOpt.add_model_constructor-Tuple{DiffOpt.Optimizer, Any}"><code>add_model_constructor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.add_model_constructor-Tuple{DiffOpt.Optimizer, Any}" href="#DiffOpt.add_model_constructor-Tuple{DiffOpt.Optimizer, Any}"><code>DiffOpt.add_model_constructor</code></a> — <span class="docstring-category">Method</span></header><section><div><p>add<em>model</em>constructor(optimizer::Optimizer, model_constructor)</p><p>Add the constructor of <a href="#DiffOpt.AbstractModel"><code>AbstractModel</code></a> for <code>optimizer</code> to choose from when trying to differentiate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.dU_from_dQ!-Tuple{Any, Any}" href="#DiffOpt.dU_from_dQ!-Tuple{Any, Any}"><code>DiffOpt.dU_from_dQ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dU_from_dQ!(dQ, U)</code></pre><p>Return the solution <code>dU</code> of the matrix equation <code>dQ = dU&#39; * U + U&#39; * dU</code> where <code>dQ</code> and <code>U</code> are the two argument of the function.</p><p>This function overwrites the first argument <code>dQ</code> to store the solution. The matrix <code>U</code> is not however modified.</p><p>The matrix <code>dQ</code> is assumed to be symmetric and the matrix <code>U</code> is assumed to be upper triangular.</p><p>We can exploit the structure of <code>U</code> here:</p><ul><li>If the factorization was obtained from SVD, <code>U</code> would be orthogonal</li><li>If the factorization was obtained from Cholesky, <code>U</code> would be upper triangular.</li></ul><p>The MOI bridge uses Cholesky in order to exploit sparsity so we are in the second case.</p><p>We look for an upper triangular <code>dU</code> as well.</p><p>We can find each column of <code>dU</code> by solving a triangular linear system once the previous column have been found. Indeed, let <code>dj</code> be the <code>j</code>th column of <code>dU</code> <code>dU&#39; * U = vcat(dj&#39;U for j in axes(U, 2))</code> Therefore, <code>dQ[j, 1:j]</code> = dj&#39;U[:, 1:j] + U[:, j]&#39;dU[:, 1:j]<code>So</code>dQ[j, 1:(j-1)] - U[:, j]&#39; * dU[:, 1:(j-1)] = dj&#39;U[:, 1:(j-1)]<code>and</code>dQ[j, j] / 2 = dj&#39;U[:, j]`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.diff_optimizer-Tuple{Any}" href="#DiffOpt.diff_optimizer-Tuple{Any}"><code>DiffOpt.diff_optimizer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diff_optimizer(optimizer_constructor)::Optimizer</code></pre><p>Creates a <code>DiffOpt.Optimizer</code>, which is an MOI layer with an internal optimizer and other utility methods. Results (primal, dual and slack values) are obtained by querying the internal optimizer instantiated using the <code>optimizer_constructor</code>. These values are required for find jacobians with respect to problem data.</p><p>One define a differentiable model by using any solver of choice. Example:</p><pre><code class="language-julia hljs">julia&gt; import DiffOpt, HiGHS

julia&gt; model = DiffOpt.diff_optimizer(HiGHS.Optimizer)
julia&gt; x = model.add_variable(model)
julia&gt; model.add_constraint(model, ...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.forward_differentiate!" href="#DiffOpt.forward_differentiate!"><code>DiffOpt.forward_differentiate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">forward_differentiate!(model::Optimizer)</code></pre><p>Wrapper method for the forward pass. This method will consider as input a currently solved problem and differentials with respect to problem data set with the <a href="#DiffOpt.ForwardObjectiveFunction"><code>ForwardObjectiveFunction</code></a> and  <a href="#DiffOpt.ForwardConstraintFunction"><code>ForwardConstraintFunction</code></a> attributes. The output solution differentials can be queried with the attribute <a href="#DiffOpt.ForwardVariablePrimal"><code>ForwardVariablePrimal</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.map_rows-Tuple{Function, Any, DiffOpt.ProductOfSets, Union{DiffOpt.Flattened, DiffOpt.Nested}}" href="#DiffOpt.map_rows-Tuple{Function, Any, DiffOpt.ProductOfSets, Union{DiffOpt.Flattened, DiffOpt.Nested}}"><code>DiffOpt.map_rows</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_rows(f::Function, model, cones::ProductOfSets, map_mode::Union{Nested{T}, Flattened{T}})</code></pre><p>Given a <code>model</code>, its <code>cones</code> and <code>map_mode</code> of type <code>Nested</code> (resp. <code>Flattened</code>), return a <code>Vector{T}</code> of length equal to the number of cones (resp. rows) in the conic form where the value for the index (resp. rows) corresponding to each cone is equal to <code>f(ci, r)</code> where <code>ci</code> is the corresponding constraint index in <code>model</code> and <code>r</code> is a <code>UnitRange</code> of the corresponding rows in the conic form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.quad_sym_half" href="#DiffOpt.quad_sym_half"><code>DiffOpt.quad_sym_half</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">quad_sym_half(func, vi1::MOI.VariableIndex, vi2::MOI.VariableIndex)</code></pre><p>Return <code>Q[i,j] = Q[j,i]</code> where the quadratic terms of <code>func</code> is represented by <code>x&#39; Q x / 2</code> for a symmetric matrix <code>Q</code> where <code>x[i] = vi1</code> and <code>x[j] = vi2</code>. Note that while this is equal to <code>JuMP.coefficient(func, vi1, vi2)</code> if <code>vi1 != vi2</code>, in the case <code>vi1 == vi2</code>, it is rather equal to <code>2JuMP.coefficient(func, vi1, vi2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.reverse_differentiate!" href="#DiffOpt.reverse_differentiate!"><code>DiffOpt.reverse_differentiate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reverse_differentiate!(model::MOI.ModelLike)</code></pre><p>Wrapper method for the backward pass / reverse differentiation. This method will consider as input a currently solved problem and differentials with respect to the solution set with the <a href="#DiffOpt.ReverseVariablePrimal"><code>ReverseVariablePrimal</code></a> attribute. The output problem data differentials can be queried with the attributes <a href="#DiffOpt.ReverseObjectiveFunction"><code>ReverseObjectiveFunction</code></a> and <a href="#DiffOpt.ReverseConstraintFunction"><code>ReverseConstraintFunction</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.standard_form" href="#DiffOpt.standard_form"><code>DiffOpt.standard_form</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">standard_form(func::AbstractLazyScalarFunction)</code></pre><p>Converts <code>func</code> to a standard MOI scalar function.</p><pre><code class="nohighlight hljs">standard_form(func::MOItoJuMP)</code></pre><p>Converts <code>func</code> to a standard JuMP scalar function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.ΔQ_from_ΔU!-Tuple{Any, Any}" href="#DiffOpt.ΔQ_from_ΔU!-Tuple{Any, Any}"><code>DiffOpt.ΔQ_from_ΔU!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ΔQ_from_ΔU!(ΔU, U)</code></pre><p>Return the symmetric solution <code>ΔQ</code> of the matrix equation <code>triu(ΔU) = 2triu(U * ΔQ)</code> where <code>ΔU</code> and <code>U</code> are the two argument of the function.</p><p>This function overwrites the first argument <code>ΔU</code> to store the solution. The matrix <code>U</code> is not however modified.</p><p>The matrix <code>U</code> is assumed to be upper triangular.</p><p>We can exploit the structure of <code>U</code> here:</p><ul><li>If the factorization was obtained from SVD, <code>U</code> would be orthogonal</li><li>If the factorization was obtained from Cholesky, <code>U</code> would be upper triangular.</li></ul><p>The MOI bridge uses Cholesky in order to exploit sparsity so we are in the second case.</p><p>We can find each column of <code>ΔQ</code> by solving a triangular linear system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.π-Union{Tuple{T}, Tuple{Vector{T}, MathOptInterface.ModelLike, DiffOpt.ProductOfSets}} where T" href="#DiffOpt.π-Union{Tuple{T}, Tuple{Vector{T}, MathOptInterface.ModelLike, DiffOpt.ProductOfSets}} where T"><code>DiffOpt.π</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">π(v::Vector{Float64}, model::MOI.ModelLike, cones::ProductOfSets)</code></pre><p>Given a <code>model</code>, its <code>cones</code>, find the projection of the vectors <code>v</code> of length equal to the number of rows in the conic form onto the cartesian product of the cones corresponding to these rows. For more info, refer to https://github.com/matbesancon/MathOptSetDistances.jl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.QuadraticProgram.LinearAlgebraSolver" href="#DiffOpt.QuadraticProgram.LinearAlgebraSolver"><code>DiffOpt.QuadraticProgram.LinearAlgebraSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearAlgebraSolver</code></pre><p>Optimizer attribute for the solver to use for the linear algebra operations. Each solver must implement: <code>solve_system(solver, LHS, RHS, iterative::Bool)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.QuadraticProgram.Model" href="#DiffOpt.QuadraticProgram.Model"><code>DiffOpt.QuadraticProgram.Model</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DiffOpt.QuadraticProgram.Model &lt;: DiffOpt.AbstractModel</code></pre><p>Model to differentiate quadratic programs.</p><p>For the reverse differentiation, it differentiates the optimal solution <code>z</code> and return product of jacobian matrices (<code>dz / dQ</code>, <code>dz / dq</code>, etc) with the backward pass vector <code>dl / dz</code></p><p>The method computes the product of</p><ol><li>jacobian of problem solution <code>z*</code> with respect to  problem parameters set with the <a href="#DiffOpt.ReverseVariablePrimal"><code>DiffOpt.ReverseVariablePrimal</code></a></li><li>a backward pass vector <code>dl / dz</code>, where <code>l</code> can be a loss function</li></ol><p>Note that this method <em>does not returns</em> the actual jacobians.</p><p>For more info refer eqn(7) and eqn(8) of https://arxiv.org/pdf/1703.00443.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.QuadraticProgram.create_LHS_matrix" href="#DiffOpt.QuadraticProgram.create_LHS_matrix"><code>DiffOpt.QuadraticProgram.create_LHS_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_LHS_matrix(z, λ, Q, G, h, A=nothing)</code></pre><p>Inverse matrix specified on RHS of eqn(7) in https://arxiv.org/pdf/1703.00443.pdf</p><p>Helper method while calling <code>reverse_differentiate!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.QuadraticProgram.solve_system-NTuple{4, Any}" href="#DiffOpt.QuadraticProgram.solve_system-NTuple{4, Any}"><code>DiffOpt.QuadraticProgram.solve_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Default <code>solve_system</code> call uses IterativeSolvers or the default linear solve</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiffOpt.ConicProgram.Model" href="#DiffOpt.ConicProgram.Model"><code>DiffOpt.ConicProgram.Model</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Diffopt.ConicProgram.Model &lt;: DiffOpt.AbstractModel</code></pre><p>Model to differentiate conic programs.</p><p>The forward differentiation computes the product of the derivative (Jacobian) at the conic program parameters <code>A</code>, <code>b</code>, <code>c</code> to the perturbations <code>dA</code>, <code>db</code>, <code>dc</code>.</p><p>The reverse differentiation computes the product of the transpose of the derivative (Jacobian) at the conic program parameters <code>A</code>, <code>b</code>, <code>c</code> to the perturbations <code>dx</code>, <code>dy</code>, <code>ds</code>.</p><p>For theoretical background, refer Section 3 of Differentiating Through a Cone Program, https://arxiv.org/abs/1904.09043</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/DiffOpt.jl">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../usage/">« Usage</a><a class="docs-footer-nextpage" href="../examples/Thermal_Generation_Dispatch_Example/">Thermal Generation Dispatch Example »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 8 January 2025 19:24">Wednesday 8 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
